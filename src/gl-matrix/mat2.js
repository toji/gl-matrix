/*
 * Copyright (c) 2012 Brandon Jones, Colin MacKenzie IV
 *
 * This software is provided 'as-is', without any express or implied
 * warranty. In no event will the authors be held liable for any damages
 * arising from the use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *
 *    1. The origin of this software must not be misrepresented; you must not
 *    claim that you wrote the original software. If you use this software
 *    in a product, an acknowledgment in the product documentation would be
 *    appreciated but is not required.
 *
 *    2. Altered source versions must be plainly marked as such, and must not
 *    be misrepresented as being the original software.
 *
 *    3. This notice may not be removed or altered from any source
 *    distribution.
 */

(function() {
    "use strict";

    /**
     * @class 2x2 Matrix
     * @name mat2
     */
    var mat2 = {};
    
    var sin = Math.sin;
    var cos = Math.cos;

    var mat2Identity = new Float32Array([
        1, 0,
        0, 1
    ]);

    /**
     * Creates a new identity mat2
     *
     * @returns {mat2} a new 2D vector
     */
    mat2.create = function() {
        return new Float32Array(mat2Identity);
    };

    /**
     * Creates a new mat2 initialized with values from an existing vector
     *
     * @param {mat2} a matrix to clone
     * @returns {mat2} a new 2x2 matrix
     */
    mat2.clone = function(a) {
        var out = new Float32Array(4);
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[3];
        return out;
    };

    /**
     * Copy the values from one mat2 to another
     *
     * @param {mat2} out the receiving matrix
     * @param {mat2} a the source matrix
     * @returns {mat2} out
     */
    mat2.copy = function(out, a) {
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[3];
        return out;
    };

    /**
     * Set a mat2 to the identity matrix
     *
     * @param {mat2} out the receiving matrix
     * @returns {mat2} out
     */
    mat2.identity = function(out) {
        out[0] = 1;
        out[1] = 0;
        out[2] = 0;
        out[3] = 1;
        return out;
    };

    /**
     * Transpose the values of a mat2
     *
     * @param {mat2} out the receiving matrix
     * @param {mat2} a the source matrix
     * @returns {mat2} out
     */
    mat2.transpose = function(out, a) {
        // If we are transposing ourselves we can skip a few steps but have to cache some values
        if (out === a) {
            var a1 = a[1];
            out[1] = a[2];
            out[2] = a1;
        } else {
            out[0] = a[0];
            out[1] = a[2];
            out[2] = a[1];
            out[3] = a[3];
        }
        
        return out;
    };

    /**
     * Inverts a mat2
     *
     * @param {mat2} out the receiving matrix
     * @param {mat2} a the source matrix
     * @returns {mat2} out
     */
    mat2.inverse = function(out, a) {
        var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
        var det = a0 * a3 - a2 * a1;
        if (!det) {
            return null;
        }
        
        det = 1.0 / det;
        out[0] =  a3 * det;
        out[1] = -a1 * det;
        out[2] = -a2 * det;
        out[3] =  a0 * det;

        return out;
    };

    /**
     * Caclulates the adjugate of a mat2
     *
     * @param {mat2} out the receiving matrix
     * @param {mat2} a the source matrix
     * @returns {mat2} out
     */
    mat2.adjoint = function(out, a) {
        // Caching this value is nessecary if out == a
        var a0 = a[0];
        out[0] =  a[3];
        out[1] = -a[1];
        out[2] = -a[2];
        out[3] =  a0;

        return out;
    };

    /**
     * Calculates the determinant of a mat2
     *
     * @param {mat2} a the source matrix
     * @returns {Number} determinant of a
     */
    mat2.determinant = function (a) {
        return a[0] * a[3] - a[2] * a[1];
    };

    /**
     * Multiplies two mat2's
     *
     * @param {mat2} out the receiving matrix
     * @param {mat2} a the first operand
     * @param {mat2} b the second operand
     * @returns {mat2} out
     */
    mat2.mul = mat2.multiply = function (out, a, b) {
        var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
        var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
        out[0] = a0 * b0 + a1 * b2;
        out[1] = a0 * b1 + a1 * b3;
        out[2] = a2 * b0 + a3 * b2;
        out[3] = a2 * b1 + a3 * b3;
        return out;
    };

    /**
     * Rotates a mat2 by the given angle
     *
     * @param {mat2} out the receiving matrix
     * @param {mat2} a the matrix to rotate
     * @param {mat2} rad the angle to rotate the matrix by
     * @returns {mat2} out
     */
    mat2.rotate = function (out, a, rad) {
        var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
            s = sin(rad),
            c = cos(rad);
        out[0] = a0 *  c + a1 * s;
        out[1] = a0 * -s + a1 * c;
        out[2] = a2 *  c + a3 * s;
        out[3] = a2 * -s + a3 * c;
        return out;
    };

    /**
     * Scales the mat2 by the dimensions in the given vec2
     *
     * @param {mat2} out the receiving matrix
     * @param {mat2} a the matrix to rotate
     * @param {mat2} v the vec2 to scale the matrix by
     * @returns {mat2} out
     **/
    mat2.scale = function(out, a, v) {
        var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
            v0 = v[0], v1 = v[1];
        out[0] = a0 * v0;
        out[1] = a1 * v1;
        out[2] = a2 * v0;
        out[3] = a3 * v1;
        return out;
    };

    /**
     * Returns a string representation of a mat2
     *
     * @param {mat2} mat matrix to represent as a string
     * @returns {String} string representation of the matrix
     */
    mat2.str = function (a) {
        return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
    };

    exports.mat2 = mat2;
})();